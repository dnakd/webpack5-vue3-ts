https://juejin.cn/post/7246777949100245049?searchId=202408251559414E6FF77870953BF41958
npm init -y
npm i webpack@5.85.1 webpack-cli@5.1.3 -D
npm i vue@^3.3.4 -S
配置loader解析ts和vue
由于webpack默认只能识别js文件,不能识别vue和ts文件，
需要借助 vue-loader 来识别vue语法。
ts文件可以借助babel-loader的预设预设
@babel/preset-typescript 来先ts语法转换为js 语法。
npm i babel-loader@^8.2.4 @babel/core@^7.22.5 @babel/preset-env@^7.22.5 @babel/preset-typescript@^7.22.5 vue-loader@^17.2.2 -D

webpack需要把最终构建好的静态资源都引入到一个html文件中,这样才能在浏览器中运行,
npm i html-webpack-plugin -D

安装 webpack-dev-server
npm i webpack-dev-server webpack-merge -D

浏览器查看打包结果
打包后的dist文件可以在本地借助node服务器serve打开,全局安装serve

npm i serve -g
然后在项目根目录命令行执行serve -s dist,就可以启动打包后的项目了。
到现在一个基础的支持vue3和ts的webpack5就配置好了,但只有这些功能是远远不够的,还需要继续添加其他配置。

环境变量，支持css，less，css3前缀，babel兼容，图片和媒体资源等。
配置完善构建速度和构建结果的优化配置，以及配置完善的代码规范和git提交规范。

cross-env --save-dev
npm i cross-env -D
修改package.json的scripts脚本字段,删除原先的dev和build,改为
"scripts": {
    "dev:dev": "cross-env NODE_ENV=development BASE_ENV=development webpack-dev-server -c build/webpack.dev.js",
    "dev:test": "cross-env NODE_ENV=development BASE_ENV=test webpack-dev-server -c build/webpack.dev.js",
    "dev:pre": "cross-env NODE_ENV=development BASE_ENV=pre webpack-dev-server -c build/webpack.dev.js",
    "dev:prod": "cross-env NODE_ENV=development BASE_ENV=production webpack-dev-server -c build/webpack.dev.js",

    "build:dev": "cross-env NODE_ENV=production BASE_ENV=development webpack -c build/webpack.prod.js",
    "build:test": "cross-env NODE_ENV=production BASE_ENV=test webpack -c build/webpack.prod.js",
    "build:pre": "cross-env NODE_ENV=production BASE_ENV=pre webpack -c build/webpack.prod.js",
    "build:prod": "cross-env NODE_ENV=production BASE_ENV=production webpack -c build/webpack.prod.js"
  }

dev开头是开发模式,build开头是打包模式,冒号后面对应的dev/test/pre/prod是对应的业务环境的开发/测试/预测/正式环境。
process.env.NODE_ENV环境变量webpack会自动根据设置的mode字段来给业务代码注入对应的development和prodction,
这里在命令中再次设置环境变量NODE_ENV是为了在webpack和babel的配置文件中访问到。

执行打包命令npm run build:dev,会发现有报错, 因为webpack默认只认识js,是不识别css文件的,需要使用loader来解析css, 安装依赖
npm run build:dev
npm i style-loader css-loader -D
style-loader: 把解析后的css代码从js中抽离,放到头部的style标签中(在运行时做的)
css-loader: 解析css文件代码

npm i less-loader less -D
less-loader: 解析less文件代码,把less编译为css
less: less核心
实现支持less也很简单,只需要在rules中添加less文件解析,遇到less文件,使用less-loader解析为css,再进行css解析流程,修改webpack.base.js：
npm i speed-measure-webpack-plugin -D

pnpm add eslint -D
pnpm eslint --init
npm install -D sass-loader sass
npm i babel-loader @babel/core @babel/preset-env core-js -D
babel-loader: 使用 babel 加载最新js代码并将其转换为 ES5（上面已经安装过）
@babel/corer: babel 编译的核心包
@babel/preset-env: babel 编译的预设,可以转换目前最新的js标准语法
core-js: 使用低版本js语法模拟高版本的库,也就是垫片

项目维护的时候,一般只会修改一部分代码,可以合理配置文件缓存,来提升前端加载页面速度和减少服务器压力,而hash就是浏览器缓存策略很重要的一部分。webpack打包的hash分三种：
hash：跟整个项目的构建相关,只要项目里有文件更改,整个项目构建的hash值都会更改,并且全部文件都共用相同的hash值
chunkhash：不同的入口文件进行依赖文件解析、构建对应的chunk,生成对应的哈希值,文件本身修改或者依赖文件修改,chunkhash值会变化
contenthash：每个文件自己单独的 hash 值,文件的改动只会影响自身的 hash 值


development(开发环境) 和 production(生产环境)这两个环境下的构建目标存在着巨大差异。
开发环境目标： 强大的 source map 和一个有着 live reloading(实时重新加载) 或 hot module replacement(模块热替换) 能力的 localhost server。
生产环境目标： 关注点在于压缩 bundle、更轻量的 source map、资源优化等，通过这些优化方式改善加载时间

在前端开发中，"bundle"（通常翻译为“捆绑”或“包”）指的是将多个文件合并成一个或几个文件的过程。
这种过程通常在构建 Web 应用程序时发生，目的是为了减少网络请求次数、优化加载性能，并简化部署流程。

合并多个文件：
一个 bundle 可以包含多个 JavaScript 文件、CSS 文件、图片文件等。这些文件被合并成一个或几个较大的文件，这样浏览器只需要发出一次请求就可以获取到所有资源。
优化和压缩：
在构建过程中，通常会对文件进行压缩、混淆等优化措施，以减小文件大小，提高加载速度。
依赖管理：
bundle 还可以帮助管理项目中的依赖关系，确保正确的加载顺序和依赖的解析。
按需加载：
现代构建工具还支持按需加载（也称为代码分割），这意味着可以将 bundle 分割成多个较小的文件，只有在需要时才加载，从而进一步提高性能。



eslint9.0
执行安装命令，我们只安装prettier本体和eslint-config-prettier配置。看过上一篇介绍eslint+prettier的同学会发现少了一个eslint-plugin-prettier插件
npm init @eslint/config@latest 或者 npx eslint --init

新版 eslint.config.{js,cjs,mjs} 已经取代了 .eslintrc 配置文件，
如果你是 “怀旧派” 可以将你的环境变量 ESLINT_USE_FLAT_CONFIG 设为 false，
但 Implement Flat Config 中已经明确表示在下一阶段（10.x）中会移除对旧配置文件的兼容。

